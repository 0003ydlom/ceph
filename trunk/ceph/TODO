sage
 mds diropen

doc
- mdsmonitor beacon semantics
- cache expiration, cache invariants
 - including dual expire states, transition, vs subtree grouping of expire messages
- recovery states, implicit barrier are rejoin
- journal content
 - importmaps and up:resolve
- metablob version semantics



mds
- finish multistage rejoin 

- more testing of failures + thrashing.
  - is export prep dir open deadlock properly fixed by forge_replica_dir()?

- locker vs node failure
- osd needs a set_floor_and_read op for safe failover/STOGITH-like semantics.
- failures during recovery stages (resolve, rejoin)... make sure rejoin still works!
- fix mds initial osdmap weirdness (which will currently screw up on standby -> almost anything)
- incremental mdsmaps?
- client failure

- dirfrag split
  - make sure we are freezing _before_ we fetch to complete the dirfrag, else 
    we break commit()'s preconditions when it fetches an incomplete dir.

- EMetablob should return 'expired' if they have higher versions (and are thus described by a newer journal entry)
- dir version/committed/etc versus migration, log expires.  
  - DOCUMENT.

- fix rmdir empty exported dirfrag race
  - export all frags <= 1 item?  then we ensure freezing before empty, avoiding any last unlink + export vs rmdir race.
  - how to know full dir size (when trimming)?
    - put frag size/mtime in fragmap in inode?  we will need that anyway for stat on dirs
      - will need to make inode discover/import_decode smart about dirfrag auth
    - or, only put frag size/mtime in inode when frag is closed.  otherwise, soft (journaled) state, possibly on another mds.
  - need to move state from replicas to auth.  simplelock doesn't currently support that.
    - ScatterLock or something?  hrm.

- test open_remote_ino

- scatterlock
  - unlink, link, rename need to pre_dirty and update dir inode's mtime
  - tho need to make sure that behaves when dirfrag's inode is non-auth...

- FIXME how to journal root and stray inode content? 
  - in particular, i care about dirfragtree.. get it on rejoin?
  - and dir sizes, if i add that... also on rejoin?

/- properly recover lock state on rejoin...
/  - recovering mds rejoins replicas it pulled out of its journal
/    - replicas will tell it when they hold an xlock
/  - surviving mds rejoins replicas from a recovering mds
/    - will tell auth if it holds an xlock
- send_rejoin_acks

- recovering open files
  - recovery will either have inode (from EOpen), or will provide path+cap to reassert open state.
    - path+cap window will require some fetching of metadata from disk before doing the rejoin
  - failures during migration.. what about client stale/reap stuff and misplaced WR caps?

- inode.max_size

- journal+recovery
  - local rename
    - how to notify replicas...
/  - stray purge
  - stray reintegration
  - remote link
    - impl remote inode xlock
    - ESlaveUpdate replay, resolution, etc.
  - remote unlink
    - rewrite to look link _link
  - remote rename
  - file capabilities i/o
- filelock to control directory mtime, dentry changes
  - hmm, may have to change lock ordering, and Server::rdlock_path_pin_ref()
- dirfrag split/merge
  - client readdir for dirfrags
- consistency points/snapshots
  - dentry versions vs dirfrags...
- real chdir (directory "open")
  - relative metadata ops
- statfs?


- fix lock caps gather ack versus ambiguous auth


foreign rename
- question: can we generalize foreign and local rename?
- initiated by dest.
  - if we get into race with lock acquisition, drop locks and forward to new dest.
- how to do pre-auth pinning?
  - is it sufficient to wait on, then grab, all local auth pins, _then_ do foreign locks?
    - local auth pins can hold subtrees in freezing state, preventing exports, and additional auth_pins.
    - so, wait, then grab all local auth_pins,
    - then work on locks in proper order (*),
      - if we detect we are missing a local auth_pin (i.e. migration race), drop all auth_pins and wait/restart
  - need to more carefully look at lock dependencies to avoid deadlock...
    - establish a complete full ordering on locks, based on any lock dependencies?
  - is it possible to "leak" locks, e.g. get inode_hard lock, work on something else, but inode moves and we dont notice?
    - pin paths for those locks?
    - can we pin when we choose order, so that locks are sure to proceed?
- we can change active_requests to key of reqid (also unique), and use the same key for foreign locks
  - clean up dentry_xlock_request.. just merge it into destroy_xlock_start, if !is_auth().  
- renamer will
  - check preconditions (i.e. i am dest)
  - grab all locks (avoiding deadlock)
  - verify preconditions are still true, else forward/retry (actually, this already happens w/ the way we structure the lock acquisition code...)
  - prepare foreign bits (using foreign request_auth_pins, locks, etc.)
    - source unlink,
    - anchortable update (if source is anchored),
    - dest nlink-- (if dest is remote link on foreign host)
  - make sure replicas have either both source+dest pinned in cache (or neither...)
    - use foreign request_pins?
  - log update
  - do update locally
  - async commit + unlock
- rejoin will need to explicitly resolve uncommitted items.
  - fully implement link/unlink first, and use that as a model?

monitor
- finish generic paxos

osdmon
- distribute w/ paxos framework
- allow fresh replacement osds.  add osd_created in osdmap, probably
- monitor needs to monitor some osds...
- monitor pg states, notify on out?
- watch osd utilization; adjust overload in cluster map

mdsmon
- distribute w/ paxos framework

journaler
- fix up for large events (e.g. imports)
- use set_floor_and_read for safe takeover from possibly-not-quite-dead otherguy.
- should we pad with zeros to avoid splitting individual entries?
  - make it a g_conf flag?
  - have to fix reader to skip over zeros (either <4 bytes for size, or zeroed sizes)
- need to truncate at detected (valid) write_pos to clear out any other partial trailing writes


crush
- xml import/export?
- crush tools


rados+ebofs
- purge replicated writes from cache.  (with exception of partial tail blocks.)

rados paper todo?
- better experiments
  - berkeleydb objectstore?
- flush log only in response to subsequent read or write?
- better behaving recovery
- justify use of splay.
  - dynamic replication
- snapshots

rados snapshots
- integrate revisions into ObjectCacher
- clean up oid.rev vs op.rev in osd+osdc

- attr.crev is rev we were created in.
- oid.rev=0 is "live".  defined for attr.crev <= rev.
- otherwise, defined for attr.crev <= rev < oid.rev  (i.e. oid.rev is upper bound, non-inclusive.)

- write|delete is tagged with op.rev
  - if attr.crev < op.rev
    - we clone to oid.rev=rev (clone keeps old crev)
    - change live attr.crev=rev.
  - apply update
- read is tagged with op.rev
  - if 0, we read from 0 (if it exists).
  - otherwise we choose object rev based on op.rev vs oid.rev, and then verifying attr.crev <= op.rev.

- how to get usage feedback to monitor?

- clean up mds caps release in exporter
- figure out client failure modes
- add connection retry.


objecter
- read+floor_lockout

osd/rados
- read+floor_lockout for clean STOGITH-like/fencing semantics after failover.
- separate out replication code into a PG class, to pave way for RAID

- efficiently replicate clone() objects
- pg_num instead of pg_bits
- flag missing log entries on crash recovery  --> WRNOOP? or WRLOST?
- consider implications of nvram writeahead logs
- fix heartbeat wrt new replication
- mark residual pgs obsolete  ???
- rdlocks
- optimize remove wrt recovery pushes
- pg_bit/pg_num changes
- report crashed pgs?

simplemessenger
- close idle connections
- buffer sent messages until a receive is acknowledged (handshake!)
  - retry, timeout on connection or transmission failure
- exponential backoff on monitor resend attempts (actually, this should go outside the messenger!)

objectcacher
- ocacher caps transitions vs locks
- test read locks

reliability
- heartbeat vs ping?
- osdmonitor, filter

ebofs
- verify proper behavior of conflicting/overlapping reads of clones
- test(fix) sync() 
- combine inodes and/or cnodes into same blocks
- allow btree sets instead of maps
- eliminate nodepools
- nonblocking write on missing onodes?
- fix bug in node rotation on insert (and reenable)
- fix NEAR_LAST_FWD (?)
- journaling? in NVRAM?
- metadata in nvram?  flash?


remaining hard problems
- how to cope with file size changes and read/write sharing


crush
- more efficient failure when all/too many osds are down
- allow forcefeed for more complicated rule structures.  (e.g. make force_stack a list< set<int> >)


mds
- distributed client management
- anchormgr
  - 2pc
  - independent journal?
  - distributed?
- link count management
  - also 2pc
- chdir (directory opens!)
- rewrite logstream
  - clean up
  - be smart about rados ack vs reread
  - log locking?  root log object
  - trimming, rotation

- efficient stat for single writers
- lstat vs stat
- add FILE_CAP_EXTEND capability bit
- only share osdmap updates with clients holding capabilities
- delayed replica caps release... we need to set a timer event? (and cancel it when appropriate?)
- finish hard links!
 - reclaim danglers from inode file on discover...
 - fix rename wrt hard links
- interactive hash/unhash interface
- test hashed readdir
- make logstream.flush align itself to stripes

- carefully define/document frozen wrt dir_auth vs hashing



client
- fstat
- mixed lazy and non-lazy io will clobber each others' caps in the buffer cache.. how to isolate..
- test client caps migration w/ mds exports
- some heuristic behavior to consolidate caps to inode auth?







why qsync could be wrong (for very strict POSIX) : varying mds -> client message transit or processing times.
- mds -> 1,2 : qsync
- client1 writes at byte 100
- client1 -> mds : qsync reply (size=100)
- client1 writes at byte 300
- client1 -> client2 (outside channel)
- client2 writes at byte 200
- client2 -> mds : qsync reply (size=200)
-> stat results in size 200, even though at no single point in time was the max size 500.
-> for correct result, need to _stop_ client writers while gathering metadata.


SAGE:

- string table?

- hard links
 - fix MExportAck and others to use dir+dentry, not inode
   (otherwise this all breaks with hard links.. altho it probably needs reworking already!)

- do real permission checks?






ISSUES


- discover
 - soft: authority selectively repicates, or sets a 'forward' flag in reply
 - hard: authority always replicates (eg. discover for export)
 - forward flag (see soft)
 - error flag   (if file not found, etc.)
 - [what was i talking about?] make sure waiters are properly triggered, either upon dir_rep update, or (empty!) discover reply



DOCUMENT
- cache, distributed cache structure and invariants
- export process
- hash/unhash process


TEST
- hashing
 - test hash/unhash operation
 - hash+export: encode list of replicated dir inodes so they can be discovered before import is procesed.
 - test nauthitems (wrt hashing?)


IMPLEMENT

- smarter balancing
  - popularity calculation and management is inconsistent/wrong.
  - does it work?

- dump active config in run output somewhere






