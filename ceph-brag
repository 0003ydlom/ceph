#!/usr/bin/env python

import subprocess
import uuid
import re
import json
import sys
import ast

CLUSTER_UUID_NAME='cluster-uuid'
CLUSTER_OWNERSHIP_NAME='cluster-ownership'

def run_command(cmd):
  child = subprocess.Popen(cmd, stdout=subprocess.PIPE,
                       stderr=subprocess.PIPE)
  (o, e) = child.communicate()
  return (child.returncode, o, e)

def get_uuid():
  (rc,uid,e) = run_command(['ceph', 'config-key', 'get', CLUSTER_UUID_NAME])
  if rc is not 0: 
    #uuid is not yet set.
    uid = str(uuid.uuid4())
    (rc, o, e) = run_command(['ceph', 'config-key', 'put', 
                             CLUSTER_UUID_NAME, uid])
    if rc is not 0:
      raise RuntimeError("\'ceph config-key put\' failed -" + e)
  
  return uid

def get_cluster_creation_date():
  (rc, o, e) = run_command(['ceph', 'mon', 'dump'])
  if rc is not 0:
    raise RuntimeError("\'ceph mon dump\' failed - " + e)
  
  rec = re.compile('(.*created\ )(.*)(\n.*)')
  
  mo = rec.search(o);
  if mo and mo.group(2) != '0.000000':
    return mo.group(2)

  # Try and get the date from osd dump
  (rc, o, e) = run_command(['ceph', 'osd', 'dump'])
  if rc is not 0:
    raise RuntimeError("\'ceph osd dump\' failed - " + e)

  mo = rec.search(o);
  if not mo or mo.group(2) == '0.000000':
    print >> sys.stderr, "Unable to get cluster creation date"
  
  return mo.group(2)

def get_nums():
  (rc, o, e) = run_command(['ceph', '-s'])
  if rc is not 0:
    raise RuntimeError("\'ceph -s\' failed - " + e)
  
  num_mons = 0

  mo = re.search('(.*monmap\ .*:\ )(\d+)(.*)', o)
  if not mo:
    raise RuntimeError("Unmatched pattern for monmap in \'ceph status\'")
  else:
    num_mons = int(mo.group(2)) 

  num_osds = 0
  mo = re.search('.*osdmap.*(\d+).*(\d+).*(\d+).*', o) 
  if not mo:
    raise RuntimeError("Unmatched pattern for osdmap in \'ceph status\'")
  else:
    num_osds = int(mo.group(1))

  num_mdss = 0
  mo = re.search('.*mdsmap\ e\d+.*(\d+)/(\d+)/(\d+).*', o)
  if mo:
    num_mdss = int(mo.group(2));

  num_pgs = 0
  num_pools = 0 
  num_bytes = 0
  num_objs = 0
  mo = re.search('.*pgmap\ v\d+:\ (\d+).*,\ (\d+).*,\ (\d+.*)\ data,\ (\d+).*', o)
  if not mo:
    raise RuntimeError("Unmatched pattern for pgmap in \'ceph status\'")
  else:
    num_pgs = int(mo.group(1))
    num_pools = int(mo.group(2))
    num_bytes = mo.group(3)
    num_objs = int(mo.group(4))
  nums = {'mons':num_mons,
          'osds':num_osds,
          'mdss':num_mdss,
          'pgs':num_pgs,
          'pools':num_pools,
          'bytes':num_bytes,
          'objects':num_objs}
  return nums

def get_crush_types():
  (rc, o, e) = run_command(['ceph', 'osd', 'crush', 'dump'])
  if rc is not 0:
    raise RuntimeError("\'ceph osd crush dump\' failed - " + e)

  crush_dump = json.loads(o)
  if crush_dump['types'] is None:
    raise RuntimeError("\'types\' item missing in \'ceph osd crush dump\'")
  
  crush_types = []
  for t in crush_dump['types']:
    crush_types.append(t['name'])

  return crush_types

def get_pool_metadata():
  (rc, o, e) = run_command(['ceph', 'osd', 'dump'])
  if rc is not 0:
    raise RuntimeError("\'ceph osd dump\' failed - " + e)

  result = re.findall("pool\ (\d+)\ '(\S+)'\ rep\ size\ (\d+)", o)
  if len(result) is 0:  
    #Check with replicated size
    result = re.findall("pool\ (\d+)\ '(\S+)'\ replicated\ size\ (\d+)", o)
    if len(result) is 0:
      raise RuntimeError("Unmatched pattern for \'pool\' in \'ceph osd dump\'")
  
  pool_meta = []
  proc = lambda x: {'id':x[0], 'name':x[1], 'rep_size':int(x[2])}
  for r in result:
    pool_meta.append(proc(r))

  return pool_meta

def get_sysinfo():
  sysinfo = []
  count = 0

  while True:
    (rc, o, e) = run_command(['ceph', 'osd', 'metadata', str(count)])
    if rc is not 0:
      break
    
    meta = {'id':count}
    os_info = {}
    hw_info = {}

    jmeta = json.loads(o)
    count = count + 1
    
    meta['ceph_version'] = jmeta['ceph_version']

    os_info['os'] = jmeta['os']
    os_info['version'] = jmeta['kernel_version']
    os_info['description'] = jmeta['kernel_description']

    try:
      distro = jmeta['distro'] + ' '
      distro += jmeta['distro_version'] + ' '
      distro += jmeta['distro_codename'] + ' ('
      distro += jmeta['distro_description'] + ')'
      os_info['distro'] = distro
    except KeyError as ke:
      pass
    meta['os_info'] = os_info

    hw_info['cpu'] = jmeta['cpu']
    hw_info['arch'] = jmeta['arch']
    hw_info['mem_kb'] = int(jmeta['mem_total_kb'])
    hw_info['swap_kb'] = int(jmeta['mem_swap_kb'])
    meta['hw_info'] = hw_info
  
    sysinfo.append(meta)
 
  return sysinfo

def get_osd_hosts():
  locs = []
  osd_id = 0
  loc = {}

  while True:
    (rc, o, e) = run_command(['ceph', 'osd', 'find', str(osd_id)])
    if rc is not 0:
      break

    jloc = json.loads(o)

    mo = re.search("(\d+.\d+.\d+.\d+).*", jloc['ip'])
    if mo is None:
      #Might be in ipv6 format, TODO: Verify 
      return None;

    ip = mo.group(1)
    host = jloc['crush_location']['host']

    if ip not in loc:
      loc[ip] = host
    elif loc[ip] != host:
      #Mismatching details
      print >> sys.stderr, "ip-hostname conflict"
      assert(0)
    
    for k,v in loc.iteritems():
      locs.append({'ip':k, 'hostname':v})
   
    osd_id += 1

  return locs

def get_ownership_info():
  (rc, o, e) = run_command(['ceph', 'config-key', 'get', 
                            CLUSTER_OWNERSHIP_NAME])
  if rc is not 0:
    return {}

  return ast.literal_eval(o)

def output_json():
  out = {}
  out['uuid'] = get_uuid()
  out['cluster_creation_date'] = get_cluster_creation_date()
  out['components_count'] = get_nums()
  out['hosts'] = get_osd_hosts()
  out['crush_types'] = get_crush_types()
  out['pool_metadata'] = get_pool_metadata()
  out['sysinfo'] = get_sysinfo()

  owner = get_ownership_info()
  if owner is not None:
    out['ownership'] = owner

  return json.dumps(out, indent=2, separators=(',', ': '))

def describe_usage():
  print >> sys.stderr, "Usage:"
  print >> sys.stderr, "======\n"

  print >> sys.stderr, sys.argv[0] + " <commands> [command-options]\n"
  print >> sys.stderr, "commands:"
  print >> sys.stderr, "publish - publish the brag report to the server"
  print >> sys.stderr, "update-metadata <update-metadata-options> - Update"
  print >> sys.stderr, "         ownership information for bragging"
  print >> sys.stderr, "clear-metadata - Clear information set by update-metadata"
  print >> sys.stderr, "unpublish --yes-i-am-shy - delete the brag report from the server"
  print >> sys.stderr, ""

  print >> sys.stderr, "update-metadata options:"
  print >> sys.stderr, "--name=  - Name of the cluster"
  print >> sys.stderr, "--organization= - Name of the organization"
  print >> sys.stderr, "--email= - Email contact address"
  print >> sys.stderr, "--description= - Reporting use-case"
  print >> sys.stderr, ""

def update_metadata():
  info = {}
  possibles = ['name', 'organization', 'email', 'description']

  #get the existing values
  info = get_ownership_info();
   
  for index in range(2, len(sys.argv)):
    mo = re.search("--(\S+)=(.*)", sys.argv[index])
    if not mo:
      describe_usage()
      return 22

    k = mo.group(1)
    v = mo.group(2)
    
    if k in possibles:
      info[k] = v
    else:
      print >> sys.stderr, "Unexpect option --" + k
      describe_usage()
      return 22

  (rc, o, e) = run_command(['ceph', 'config-key', 'put', 
                            CLUSTER_OWNERSHIP_NAME, str(info)])
  return rc

def clear_metadata():
  (rc, o, e) = run_command(['ceph', 'config-key', 'del', 
                            CLUSTER_OWNERSHIP_NAME])
  return rc

def main():
  if len(sys.argv) is 1:
    print output_json()
    return 0
  elif sys.argv[1] == 'update-metadata':
    return update_metadata()
  elif sys.argv[1] == 'clear-metadata':
    return clear_metadata()
  elif sys.argv[1] == 'publish':
    data = output_json()
    #TODO: post this data to the server
    return 0
  elif sys.argv[1] == 'unpublish':
    if len(sys.argv) <= 2 or sys.argv[2] != '--yes-i-am-shy':
      print >> sys.stderr, "unpublish should be followed by --yes-i-am-shy"
      return 22

    #TODO: delete this data from the server
    return 0
  else:
    describe_usage()
    return 22

if __name__ == '__main__':
  sys.exit(main())
