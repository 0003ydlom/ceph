v0.8
/- osd recovery fixes
/- backup homiebackup5
/- backup backup.
/- bug fixes?
/- mount error reporting
/- fix mds file size/mtime recovery
/- changes for 2.6.30
/- mds cap fixes
/- crush fixes

v0.9
/- make mds exhert memory pressure on client caps, leases
/- librados
/  - async io
/  - list_objects
/  - rados
/    - --snap N
/    - fetch/store/remove object
/    - list objects
/    - list pools
/- object classes
/- crush bugfixes
/- kclient readdir fixes

v0.10
/- kclient
/  - fix unaligned memory access
/  - fix op replay after mds restart (symlink ops)
/- fix rados snaps vs 'ls'
/- improved monitor read model
- osd bugfixes

bugs
09.07.07 16:54:31.246206 mds0.locker  ignoring client capid 698 != my 1081

mds/Locker.cc: In function 'void Locker::eval_gather(SimpleLock*, bool, bool*)':
mds/Locker.cc:386: FAILED assert(!lock->is_stable())
 1: ./cmds(_Z18__ceph_assert_failPKcS0_iS0_+0x34) [0x91b17a]
 2: ./cmds(_ZN6Locker11eval_gatherEP10SimpleLockbPb+0xbf) [0x8040cf]
 3: ./cmds(_ZN7MDCache15do_file_recoverEv+0x336) [0x787eb6]
 4: ./cmds(_ZN7MDCache10_recoveredEP6CInodei+0x1bf) [0x7880c9]
 5: ./cmds(_ZN13C_MDC_Recover6finishEi+0x27) [0x7fd64f]
 6: ./cmds(_ZN5Filer7_probedEPNS_5ProbeERK8object_tm7utime_t+0xb60) [0x8d46d2]
 7: ./cmds(_ZN5Filer7C_Probe6finishEi+0x3f) [0x8d9f97]
 8: ./cmds(_ZN8Objecter6C_Stat6finishEi+0xa0) [0x8d9b34]
 9: ./cmds(_ZN8Objecter19handle_osd_op_replyEP11MOSDOpReply+0xa9d) [0x8aec39]
 10: ./cmds(_ZN3MDS9_dispatchEP7Message+0x8b0) [0x6e838e]
 11: ./cmds(_ZN3MDS13dispatch_implEP7Message+0x69d) [0x6e979b]
 12: ./cmds(_ZN10Dispatcher9_dispatchEP7Message+0x54) [0x6c4d8e]
 13: ./cmds(_ZN10Dispatcher8dispatchEP7Message+0x1d) [0x6cccff]
 14: ./cmds(_ZN9Messenger8dispatchEP7Message+0x56) [0x6db42e]
 15: ./cmds(_ZN15SimpleMessenger8Endpoint14dispatch_entryEv+0x5cb) [0x6d5351]
 16: ./cmds(_ZN15SimpleMessenger8Endpoint14DispatchThread5entryEv+0x19) [0x6e1627]
 17: ./cmds(_ZN6Thread11_entry_funcEPv+0x20) [0x6db97e]
 18: /lib/libpthread.so.0 [0x2b25cda38fc7]
 19: /lib/libc.so.6(clone+0x6d) [0x2b25ce4b75ad]
 NOTE: a copy of the executable, or `objdump -rdS <executable>` is needed to interpret this.



later
- authentication
- client reconnect after long eviction; and slow delayed reconnect
- ENOSPC
  - space reservation in ObjectStore, redeemed by Transactions?
  - reserved as PG goes active; reservation canceled when pg goes inactive
  - something similar during recovery
  - ?
- repair
- mds security enforcement
- client, user authentication
- cas
- osd failure declarations
- rename over old files should flush data, or revert back to old contents

rados
- perl swig wrapper
- 'rados call foo.bar'?
- merge pgs
- destroy pg_pools
- autosize pg_pools?
- security

repair
- repair metadata.. 
/  - parent pointer on CDir objects
  - update on dir rename commit
- namespace reconstruction tool
- repair pg (rebuild log)  (online or offline?  ./cosd --repair_pg 1.ef?)
- repair file ioctl?
- are we concerned about
  - scrubbing
  - reconstruction after loss of subset of cdirs
  - reconstruction after loss of md log
- data object 
  - path backpointers?
  - parent dir pointer?
- cdir objects
  - parent dir pointer
    - update on rename?  or on cdir store?
      on cdir store is sufficient if mdlog survives...
  - or what the hell, full trace?
- mds scrubbing

kclient
- return EBADF on files without caps
- fix up mds selection, and ESTALE handling
- make cap import/export efficient
- simplify mds auth tracking?
  - use caps instead?
- unwind writeback start error in addr.c (see fixme)... by redirtying pages?
- flock, fnctl locks
- ACLs
- make writepages maybe skip pages with errors?
  - EIO, or ENOSPC?
  - ... writeback vs ENOSPC vs flush vs close()... hrm...
- set mapping bits for ENOSPC, EIO?
- should we try to ref CAP_PIN on special inodes that are open?  
- fix readdir vs fragment race by keeping a separate frag pos, and ignoring dentries below it
- reconnect after being disconnected from the mds
- inotify for updates from other clients?

vfs issues
- real_lookup() race:
  1- hash lookup find no dentry
  2- real_lookup() takes dir i_mutex, but then finds a dentry
  3- drops mutex, then calld d_revalidate.  if that fails, we return ENOENT (instead of looping?)
- vfs_rename_dir()
- a getattr mask would be really nice

filestore
- make min sync interval self-tuning (ala xfs, ext3?)
- get file csum?

btrfs
- clone compressed inline extents
- ioctl to pull out data csum?

osd
- what to do with lost objects.. continue peering?
- segregate backlog from log ondisk?
- preserve pg logs on disk for longer period
- make scrub interruptible
- optionally separate osd interfaces (ips) for clients and osds (replication, peering, etc.)
- pg repair
- pg split should be a work queue
- optimize remove wrt recovery pushes?

uclient
- readdir from cache
- clean up client mds session vs mdsmap behavior?
- stop using mds's inode_t?
- fix readdir vs fragment race by keeping a separate frag pos, and ignoring dentries below it

mds
- fix file recovery
  - make sure we recover mtime, not just size.. i.e. max_size > 0, not > size.
  - disallow access until file is recovered?
  - how to not recover if all clients have reconnected?
- add an up:shadow mode?
  - tail the mds log as it is written
  - periodically check head so that we trim, too
- handle slow client reconnect (i.e. after mds has gone active)
- anchor_destroy needs to xlock linklock.. which means it needs a Mutation wrapper?
  - ... when it gets a caller.. someday..
- add FILE_CAP_EXTEND capability bit
- dir fragment
  - maybe just take dftlock for now, to keep it simple.
- dir merge
- snap
  - hard link backpointers
    - anchor source dir
    - build snaprealm for any hardlinked file
    - include snaps for all (primary+remote) parents
  - how do we properly clean up inodes when doing a snap purge?
    - when they are mid-recover?  see 136470cf7ca876febf68a2b0610fa3bb77ad3532
  - what if a recovery is queued, or in progress, and the inode is then cowed?  can that happen?  
  - proper handling of cache expire messages during rejoin phase?
    -> i think cache expires are fine; the rejoin_ack handler just has to behave if rejoining items go missing

- clustered
  - on replay, but dirty scatter replicas on lists so that they get flushed?  or does rejoin handle that?
  - linkage vs cdentry replicas and remote rename....
  - rename: importing inode... also journal imported client map?



journaler
- fix up for large events (e.g. imports)
- should we pad with zeros to avoid splitting individual entries?
  - make it a g_conf flag?
  - have to fix reader to skip over zeros (either <4 bytes for size, or zeroed sizes)
- need to truncate at detected (valid) write_pos to clear out any other partial trailing writes


mon
- mds injectargs N should take mds# or id.  * should bcast to standy mds's.
- paxos need to clean up old states.
  - default: simple max of (state count, min age), so that we have at least N hours of history, say?
  - osd map: trim only old maps < oldest "in" osd up_from

osdmon
- monitor needs to monitor some osds...

pgmon
/- include osd vector with pg state
  - check for orphan pgs
- monitor pg states, notify on out?
- watch osd utilization; adjust overload in cluster map

crush
- allow forcefeed for more complicated rule structures.  (e.g. make force_stack a list< set<int> >)

simplemessenger
- close idle connections?

objectcacher
- read locks?
- maintain more explicit inode grouping instead of wonky hashes

cas
- chunking.  see TTTD in
   ESHGHI, K.
   A framework for analyzing and improving content-based chunking algorithms.
   Tech. Rep. HPL-2005-30(R.1), Hewlett Packard Laboratories, Palo Alto, 2005. 
