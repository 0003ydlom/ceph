
- stability
 - ebofs table.remove() thing
 - fakestore crapping out.. missing timer events?
mpiexec -l -n 30 ./tcpsyn --mkfs --ebofs --syn until 100 --syn writefile 1000 65536 --nummds 1 --numclient 100 --numosd 6 --kill_after 300 --file_layout_num_rep 1 --debug_after 110 --debug_osd 15 --debug_filer 15 --debug 5 --mds_shutdown_check 60 --log_name osd/write_sizes.sdb2.ebo.file2/fs=ebofs,writefile_size=65536

2: tcpsyn: mds/MDCache.cc:2388: void MDCache::handle_cache_expire(MCacheExpire*): Assertion `in->state_test((1<<6))' failed.
2: tcpsyn: mds/MDCache.cc:2388: void MDCache::handle_cache_expire(MCacheExpire*): Assertion `in->state_test((1<<6))' failed.
2: mds1 on tcprank 3 googoo-27.2013
2: mds1 on tcprank 2 googoo-27.1693

1: tcpsyn: mds/MDCache.cc:2382: void MDCache::handle_cache_expire(MCacheExpire*): Assertion `in' failed.
0 on tcprank 24 googoo-17.21123



- rados
 - redo all the recovery stuff
 - fix object ov/nv thing?  (tcpmessenger locking bug?)
   (object version AND mtime?)

- client OBJECT cache
 - lazyio_*

- clean up tcpmessenger

- mds
 - figure out weird 40ms latency with double log entries

mds
- statlite
- stat single writer
- truncate()
- chdir (directory opens!)
- delayed replica caps release... we need to set a timer event!  (and cancel it when appropriate)

client
- flesh out posix layer
- statlite
/- readdir + stat
- readdirplus
- lazy_*  (after object cache)

- test client caps with meta exports
- some heuristic behavior to consolidate caps to inode auth
- client will re-tx anything it needed to say upon rx of new mds notification (?)

- readv+writev, readx+writex
  - serialized!


filer/osd
- atomic write spanning objects...


ebofs
- fix NEAR_LAST_FWD   (?)
- combine inodes into same blocks?
- delay allocation
  - actually, reallocate if dirty is cancelable
- journaling
- nix oc_tab, move into onode.
- clone()

osd
- osdmap history distribution

- handle down osds
- pg_bit changes

- watch osd utilization; adjust cluster map




cluster issues
- general problem: how to do posix ordering on object boundaries using an object store

- osd states:
   data placement vs liveness:  active, inactive, down, failed
- failure model:
   anything more than that?  "temporarily unavailable" type state (for, say, fsck)?

- replication latency.   flush on replicas?
- what does 'complete' mean on new primary?
  - apparently _need_ to examine objects lists always?  would be nice if we didn't!
- "lazy" flush mode, for (just) doing read/write or write/write sharing?


- deleting objects
 - osd's that rejoin
 - must keep stray replicas clean

- communications failure model.. is it appropriate?
  - reliable, ordered, buffered and flushed on 'down' boundaries?
  - ordered, unreliable?
- what about large messages?  :(




REPLICATION

requirements
- We should support a fast succession of map updates, even when intermediate reorganizations are not allowed to complete before the next starts.
- Reorganizations can be arbitrary, potentially involving a completely disparate set of OSDs in a RG between epochs.  (We will of course seek to minimize movement in practice.)



- interactive hash/unhash interface
- test hashed readdir
- make logstream.flush align itself to stipes

- carefully define/document frozen wrt dir_auth vs hashing





KNOWN MDS BUGS to fix after fast
- posix extensions
 - softstat
- implement truncate() for real
- finish hard links!
 - reclaim danglers from inode file on discover...
 - fix rename wrt hard links



MDS TODO
- fix hashed readdir: should (optionally) do a lock on dir namespace
- fix hard links
  - they mostly work, but they're fragile
- sync clients on stat
  - will need to ditch 10s client metadata caching before this is useful
  - implement truncate
- implement hashed directories
- statfs?
- rewrite journal + recovery
- figure out online failure recovery
- more distributed fh management?
- btree directories (for efficient large directories)
- consistency points/snapshots

OSD TODO
- heartbeat
- collaborative write replication/commit protocol
- collections
- osd failure recovery
- osd cluster expansion

CLIENT TODO
- buffer cache
  - set proper uid/gid 
  - use unused buffer tail allocation before allocating new memory
  - periodic trim_bcache calls
- strong consistency
  - get short-term leases from MDS (for stat etc)
- ditch FUSE for ____



- fix MExportAck and others to use dir+dentry, not inode
  (otherwise this all breaks with hard links.. altho it probably needs reworking already?)


why qsync could be wrong (for very strict POSIX) : varying mds -> client message transit or processing times.
- mds -> 1,2 : qsync
- client1 writes at byte 100
- client1 -> mds : qsync reply (size=100)
- client1 writes at byte 300
- client1 -> client2 (outside channel)
- client2 writes at byte 200
- client2 -> mds : qsync reply (size=200)
-> stat results in size 200, even though at no single point in time was the max size 500.
-> for correct result, need to _stop_ client writers while gathering metadata.


SAGE:

- figure out threading, locking stuff in client

- global sync (to be used by shutdown)
  - flush all dirty data to disk
  - flush logs/journals

- scatter/gather parallel sendrecv (for client file i/o)?
  - use Filer, Cond's
- prefetch?

- sync clients on stat
  - truncate

- readdir
 - set up waiters for pending xlocks

fully document export process
 - including the whole warning business.. wtf is that about again?

- string table?

- hard links
 - fix MExportAck and others to use dir+dentry, not inode
   (otherwise this all breaks with hard links.. altho it probably needs reworking already!)

- do real permission checks?

- journal entries, recovery system


CLIENT TODO

- statfs
- readdir content only optionally includes valid inode info
- pay attention to file_caps on read, write
  - block on lacking caps



FILE STUFF (old)

- send all file writers to auth
  - migrate open file ppl w/ export
  - simplify replica softlock craziness!

- locks versus import.. big mess!
  - consider active reader+writer on auth at time of export.  how to relax?
  - relaxation in general is tricky..
  - assimilating auth state on importer also tricky.  gather_set weirdness.

- half-assed async for file writers
 - auth needs to know about replicas with writers...
   - opens go to auth
   - auth has set of replica_writers
   - on close, replica tells auth
- replace replica_writers open/close bit will full-blown soft_start/soft_finish hooks?
- need to sync or qsync clients!

- import port soft writer on dir mtime/size...

- recall messages?
- lazy flag?  make a table!
- state diagram for master?  _eval() functions?


- think about softlock.mode versus shutdown
- qsync

- freeze interaction.....  test!
  - freeze state diagram?




ISSUES


- discover
 - soft: authority selectively repicates, or sets a 'forward' flag in reply
 - hard: authority always replicates (eg. discover for export)
 - forward flag (see soft)
 - error flag   (if file not found, etc.)
 - [what was i talking about?] make sure waiters are properly triggered, either upon dir_rep update, or (empty!) discover reply



CLEANUP
- waiters after export... fix will_fail, will_delegate nonsense
 - should a subset of these waiters be triggered immediately after
   export, since discover-based contexts will just be forwarded to the
   new auth?


DOCUMENT
- cache, distributed cache structure and invariants
- export process
- hash/unhash process


TEST
- hashing
 - test hash/unhash operation
 - hash+export: encode list of replicated dir inodes so they can be discovered before import is procesed.
 - test nauthitems (wrt hashing?)


IMPLEMENT

- truncate

- hash + unhash!

- dir sync
 - stat of a dir should return dir mtime?
 - readdir of hashed dir


- smarter balancing
  - popularity calculation and management is inconsistent/wrong.
  - does it work?

- instrumentation!
- dump active config in run output somewhere

- anchors
- hard links

